---
title: TCP三次握手四次挥手
date: 2018-03-27 16:11:52
tags: 传输层
categories:
- 网络学习
- 传输层
---

首先来看一下TCP传输协议的报文格式中关于建立连接需要用到的一些比较重要的标志位。

![](https://i.imgur.com/ckjFsj8.jpg)

<!--more-->
1.seq:32位序列号，占四个字节，范围在[0-2^32-1],因为TCP是面向字节流的，所以它需要为发送流中的每个字节编号，这个序列号是使用随机数产生器产生的。（只产生一次，后面顺序向上递增）

2.ACK：32位确认序号,仅当保留位旁边的ACK=1的时候确认序号才生效，其表示一个进程已经正确接收序列号为N的字节，要求下一次接收的应该是N+1序列号的字节，所以如果接收到了序列号为N，则ACK回复为N+1(注意和确认ACK位区分)

3.SYN:（同步位）同步序列号，用来发起一个连接，当SYN=1，ACK=0的时候，表示这是一个发起连接的报文请求段。如果对方同意建立连接则会回应SYN=1，ACK=1。（系统规定SYN=1的报文段不能携带数据，但是要消耗掉一个序列号）

4.FIN：（终止位）,终止位用来终止连接，当FIN=1,表示发送端的报文发送完毕，请求关闭连接。

好了下面来谈谈三次握手的建立连接的过程.

1.首先客户端和服务器端都处于CLOSE状态（关闭状态），并且服务器端已经创建了传输控制块TCB，即时刻准备接收客户端的请求，即服务器端就进入了LISTEN（监听状态）状态

2.客户端运行起来以后，也创建了传输控制块PCB，然后向B发送了连接请求的报文。这个报文首部的SYN标志位被设置成1，即SYN=1，同时随机选择一个初始的序号，这里假设为x,即seq=x(系统规定SYN=1的报文段不能携带数据，但是要消耗一个序列号)，当这个报文发送出去以后，客户端就有CLOSE变成了SYN_SENT状态（同步已经发送的状态）

3.服务器端接收到客户端发来的请求建立连接的报文请求得话则，则向A发送确认报文（也不带数据）。这个回复的报文中SYN=1,seq=y,ACK=x+1（确认序列号），告诉客户端你发的建立请求得要求我收到了，我同意和你建立请求，然后发送完后服务器端进入了SYN_RCVD的状态（准备接收，也可以说同步收到）

4.当客户端收到了服务器的同意建立连接请求后，还要给服务器端回应我收到了你的同意建立连接的报文,回复给服务器的报文是ACK=y+1,seq=x+1, TCP的标准规定，ACK的报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq = x+1。这时TCP连接已经建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到收到客户端的确认后报文后，也进入ESTABLISHED状态。 

致此整个连接建立的过程就完了，下面我来画个图说明一下


![](https://i.imgur.com/YSBXs1Y.jpg)

看图就是这么简单。。。。




下面来说一下四次挥手断开连接

在他们通信完成以后，双方还都是ESTABLISHED状态，并且断开连接的请求服务器和客户端都可以发起，我们这里说一下客户端先发起断开连接的请求。

1.当客户端准备结束这次的数据传输的时候，主动提出释放TCP连接时，它向服务器发送一个连接释放请求的报文，FIN=1，seq=u,(这里的u等于之前传送的数据最后一个字节的序列号+1)，然后客户端进入FIN_WAIT_1(释放等待1的状态,等待服务器端的确认),TCP规定：FIN报文段即使不携带数据，也要消耗掉一个序号。 

2.当服务器端收到客户端的请求断开连接的报文后，需要向客户端发出已收到断开连接的报文请求得确认报文，ACK=u+1，seq=v（v表示服务器端之前发送的最后的数据的最后一个字节的序列号+1）,然后服务器进入CLOSE_WAIT状态。

注： TCP服务器进程此时应该通知高层应用进程，因为从A到B这个方向的连接已经关闭，这时的TCP进程属于半关闭（half_close）状态，即客户端已经不会给服务器发送数据了，但服务器要向客户端发送数据，客户端还得接收。 

3.当客户端收到服务器发来的ACK（确认断开连接报文后），进入FIN_WAIT_2的状态（释放等待2的状态，等待服务器端发送断开连接的请求），如果服务器端没有数据要发送了，应用程序通知服务器发送断开连接的请求，即向客户端发送断开连接的请求报文FIN=1,seq=w(假设客服端发送断开连接请求以后，服务器还给客户端发送消息了)，并且还要重复确认之前的ACK=u+1,然后服务器就进入了LAST_ACK状态（等待客户端回应自己的断开连接请求）

4.当客户端收到了服务器发来的要断开连接的请求后，回复给服务器ACK=w+1,seq=u+1,然后进入TIME_WAIT等待时间的状态，但是，现在TCP连接还没有释放，必须经过时间等待计时器（TIME_WAIT timer）设置的时间2MSL后，A才能进入到CLOSED状态。

下面画出示意图：
![](https://i.imgur.com/QZqf9nu.jpg)

这里说一下这个TIME_WAIT：

为了保证TCP连接释放过程的正常进行，TCP设置了时间等待器即TIME_WAIT timer.这个时间一般是2MSL（两个最长报文寿命时间），这个时间过后客户端才能真正进入CLOSE状态。


TCP状态转换图
![](https://i.imgur.com/cZqQddI.jpg)

CLOSED：表示初始状态。

LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。

SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。

SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。

ESTABLISHED：表示连接已经建立。

FIN_WAIT_1:  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：
FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。

FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。

FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。

TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。

CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。

CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。

LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。

-------------------------------------------------------------------------------
2MSL存在理由？

在客户端发送出最后的ACK回复，但该ACK可能丢失。服务器如果没有收到ACK，服务器将不断重复给客户端发送FIN片段。所以客户端不能立即关闭，它必须确认服务器接收到了该ACK。客户端会在发送出ACK之后进入到TIME_WAIT状态。客户端会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么客户端会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等

--------------------------------------------------------------------------------
为什么建立是三次握手，断开时四次握手呢？

这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建立连接请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一 个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但你所有的数据未必都全部发送给对方了，所以你未必会马上会关闭SOCKET,即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

---------------------------------------------------------------------------------
如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

--------------------------------------------------------------------------------
为什么不能用两次握手进行连接？

不用三次的话，server不能确定client是否收到自己的消息
如果没有收到，可能client根本没收到，或者client响应了，但server没收到

