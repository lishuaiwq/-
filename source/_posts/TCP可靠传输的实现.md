---
title: TCP可靠传输的实现
date: 2018-04-02 17:02:57
tags: TCP
categories:
- 网络学习
- 传输层
---

此篇博客的主要内容

1.TCP的拥塞控制

2.TCP的滑动窗口（实现流量控制）

<!--more-->

## 1.拥塞控制

首先你需要对于拥塞的概念有个了解，接下来才能去探究TCP是如何实现拥塞控制的。

拥塞：简单的说就是网络中对某一资源的需要量大于该资源所能提供的可用部分，那么就会造成网络的性能变差，这就叫做拥塞。因为产生网络拥塞的原因有很多，而且情况复杂所以处理起来就很麻烦。

TCP处理拥塞的机制：它使用了四种算法结合起来来合理的控制网络拥塞，即慢开始、拥塞避免、快重传、和快恢复。下面我就来详解介绍一下这种拥塞处理的机制


1.慢开始和拥塞避免

为了防止网络拥塞的问题产生，那么发送维持一个叫做拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度（即拥塞窗口是会变化的）。发送方让自己的发送窗口等于其拥塞窗口的大小。发送方对于这个定义的拥塞窗口的控制原则是只要网络没有出现拥塞的现象，则将拥塞窗口增大，只要发现或者察觉可能会出现拥塞则将窗口的值减小，通过这样来防止网络拥塞。那么发送端如何察觉即将或者可能发生了拥塞现象呢？
 
他是这样做的，当网络发生拥塞的时候，路由器就会丢弃一些分组，所以当发送方没有在计数器范围内收到确认消息的话，就可以猜测是不是出现了网络拥塞。即判断条件就是是否出现了超时。

这是前面为讲解后续的算法做的一些铺垫你大概对于发送端如何判断及操作拥塞窗口有了一些了解以后，下面我们来讲具体的做法。

慢开始：最开始的时候对于网络的情况是未知的，所以将拥塞窗口cwnd=1,发送第一个报文，收到确认以后，cwnd=2,则发送两个报文，再两个都收到确认以后，cwnd=4,发送四个报文。。。以此类推。。这就是满开始，这里的慢并不是说cwnd的增长速度慢，而是说一开始将cwnd设置为1，这比起来一次性发送很多的报文，要慢的多。。当然如果仅仅是满开始肯定不行因为，随着cwnd的增多，发送的数据报越来越多，造成拥塞是肯定的，，所以就需要设置一个慢开始门限（ssthresh）,则当

cwnd<ssrhresh时，继续保持慢开始

cwnd>ssthresh时，停止使用慢开始算法而变成使用拥塞避免算法

cwnd=ssthresh时，即可以使用慢开始算法也可以使用拥塞避免算法

拥塞避免：不是像慢开始阶段那样成2 4 8 16 这样的增长，而是每经过一个往返时间RTT就把拥塞窗口加1,即一个轮询+1，好比 1 2 3 4 5这样的增长方式，比之前的慢增长方式慢。这里要理解这个拥塞避免就是防止产生拥塞。。下面来看一幅图

![](https://i.imgur.com/r3SOwF2.jpg)

最开始到①之前都是慢启动，达到ssthresh以后开始实现拥塞避免，当拥塞窗口值达到24的时候，出现了超时，这个时候认为发生了网络阻塞。所以讲ssthresh的值调整为ssthresh=cwnd/2=12,然后继续开始慢启动，当拥塞窗口的值达到12时，继续使用拥塞避免，这个时候当拥塞窗口的值等于16的时候（④），发送方连续收到了三个ACK重复确认消息。那么这个时候发送方如何判断呢？？对于这个问题需要解释一下：

有时候个别报文会在网络中丢失但是并没有发生网络阻塞的现象。如果发送方迟迟收不到确认消息就会认为发生了网络拥塞，那么就会再次启动慢启动重设ssthresh的值，这样的话会降低传输的速率。。这就引出来了快重传算法和快恢复。。

快重传和快恢复：只要发送方收到了连续的三个ACK重复确认报文，就说明接收方确实没有收到相应的报文，所以立即重传对于的报文，这样就不会出现超时，发送方也不会认为出现了网络延迟，从而避免可不必要的慢开始的启动。使用快重传机制大概可以使网络吞吐量提高0.2..所以④处收到三个重复的确认消息以后，立即快重传，然后没有实行慢启动而是实行了快恢复，然后将ssthresh设置俄日ssthresh=cwnd/2=8,然后继续执行拥塞避免。。

可以看出来在拥塞避免阶段，拥塞窗口是线性增长的，这个通常称为加法增大。一旦出现超时或者三个重复的确认，就把门限减为cwnd的1/2,这个称为乘法减小，这两种方法结合在 一起称为AIMD算法.

下面给出流程处理图：

![](https://i.imgur.com/dSih53X.jpg)

实际情况下，发送方的窗口值应该等于接收方和拥塞窗口值中比较小的那个。

所以当rwnd<cwnd的时候：接收方窗口限制了发送方窗口的最大值

rwnd>cwnd：网络拥塞程度限制了发送方窗口的最大值

也就是说rwnd和cwnd中较小的一个控制了发送数据的速率。

### 主动管理队列（AQM）

因为上面提到的拥塞控制只是TCP层面的没有牵扯网络层。可是他们之间有着密切的联络。那么有这么情况，一个路由器可能链接了多个主机服务器即会有多个链接，所以当路由器队列满的时候，采取了尾部丢弃策略以后，可能会导致一连串分组的丢失，那么就会对发送方产生延迟，这里可能有很多个发送方，所以多个发送方都认为产生了网络延迟则将ssthresh=cwnd/2;然后重新开始慢启动，那么同一时间很多发送方式慢启动，那么意味着他们同时达到发送高峰，这也 很容易再次引起拥塞。这就叫做全局同步。所以为了避免发生这种情况。。就提出了主动管理队列，即路由器不要等到满了才丢弃，而是当队列长度达到某个值，可能将要发生拥塞的时候，就丢弃一些分组，这样就提醒了个别发送方放慢了传送速率。。所以有可能减轻网络的拥塞，甚至不出现拥塞。这里的丢弃就是随机丢弃，不然全部丢弃的话和队列满了的效果是一样的。。所以ARQ的实现方法就是随机早期检测（RED），实现RED需要路由器维护两个参数，即队列长度的最大限度和最小限度

1.若平均队列长度小于最小限制，则把新收到的假如队列

2.若平均队列长度大于最大限制，则把新到达的丢弃

3.介于最大和最小之间，则按照某个丢弃概率把新到达的分组丢弃（这就体现了随机丢弃）。

这里的这个概率是最难的。。有兴趣的可以了解一下。。通过这种方法就避免了上面描述的那种情况产生的拥塞。。


好了致此TCP的拥塞控制就全部讲完了。。

## 2.滑动窗口

TCP滑动窗口是以字节为单位的。

