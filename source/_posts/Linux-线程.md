---
title: Linux_线程
date: 2018-03-30 09:12:42
tags: 线程
categories:
- Linux
- 系统编程
---

此篇博客主要介绍一下关于线程的概念及线程控制原语。

首先在Linux下并不存在真正意义上的线程，他是由进程模拟出来的。所以可以说线程是轻量级的进程，其本质也是进程。进程和线程的区别是进程有自己独立的地址空间（整租）而线程没有自己独立的地址空间（合租），从内核中看线程和进程是一样都有PCB，只不过PCB中指向资源的三级页表是相同的，创建线程和进程底层使用的函数都是clone，进程可以蜕变成线程，在Linux下，线程是最小的调度单位，CPU是最小的资源分配的单位，可以将进程看成只有一个线程的进程。

<!--more-->

线程之间共享的资源：

1.文件描述符表

2.每种信号的处理方式

3.当前工作目录

4.用户ID和组ID

5.内存地址空间 (.text/.data/.bss/heap/共享库)

线程非共享资源：

1.线程id

2.处理器现场和栈指针(内核栈)

3.独立的栈空间(用户空间栈)

4.errno变量

5.信号屏蔽字

6.调度优先级

线程的优缺点：

- 优点：1. 提高程序并发性	2. 开销小	3. 数据通信、共享数据方便
- 缺点 ：1. 使用的是库函数，不稳定	2. 调试、编写困难、gdb不支持	3. 对信号支持不好
优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。

下面来看一下关于线程中的控制原语

#### 1.创建一个线程

		#include <pthread.h>

       int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);
参数：

1.pthread:是线程的ID，是线程库管理分配的用来操作使用线程.穿入传出参数

2.attr:表示所使用的线程属性，是一个结构体类型，里面包含了一些所创建的线程的属性值得设置，一般使用NULL，表示使用线程的默认属性

3.start_routine：表示我们所要创建的线程的函数，其类型是返回值void*，参数也是void*，

4.arg:表示给我们所创建的线程传的参数

注意：

1.当pthread_create成功返回的时候，新创建的线程ID会被设置为pthread指向的内存单元,新创建的线程从start_routine函数的地址开始运行，如果需要向函数传递多个参数的话，需要将这个参数放到一个结构体中，然后将结构体的地址 作为atg参数传递过去

2.在创建新线程的时候让主线程sleep(1)秒，不然的话新创建的线程还来不及执行，主线程已经返回退出了


---------------------------------------------------------------------------------

#### 2.获取线程的ID

 		#include <pthread.h>

       pthread_t pthread_self(void);

此函数返回我们所创建的线程的ID，其实可以理解为线程在一个地址空间中的标识，用来方便我们使用这个线程，其类型是长整型，记得打印的时候使用lu。


---------------------------------------------------------------------------------

#### 3.线程的退出函数

 	#include <pthread.h>

       void pthread_exit(void *retval);

参数：retval表示线程的退出状态，通常情况下传NULL。

注意：如果进程中的任意线程调用了exit,_Exit或者_exit，那么整个进程就会终止，与此类似的是如果某个线程收到了一个终止进程的信号，那么这个进程也会终止。

单线程的退出方式有三种

1.单线程可以从简单的启动例程返回。，返回值是线程的退出码。（return,不适用main函数 ）

2.其可以被同一进程中其他的线程取消(pthread_cancel)

3.线程调用上述 函数pthread_exit退出。

当某个线程调用了pthread_exit函数以后，则其他的线程可以调用如下的函数来获取线程的退出状态，调用这个函数的线程会阻塞，直到获取的线程调用pthread_exit或者从启动例程返回或者线程被取消

		#include <pthread.h>

       int pthread_join(pthread_t thread, void **retval);

参数

1.要获取的线程的ID

2.

如果线程从例程返回(return)，则retval指向的内存单元中的值是return的返回值

如果线程被pthread_cancel掉，那么retval指向的内存单元中的值是PTHREAD_CANCELED

如果线程是pthread_exit，则retval指向的内存单元中的值是pthread_exit的参数

如果对其退出值不感兴趣，则将retval设置为null。

上面既然讲了pthread_cancel强迫线程退出，那么下面就来说一下这个函数

 		#include <pthread.h>

       int pthread_cancel(pthread_t thread);
一个线程调用这个函数可以请求取消同一进程中的其他线程。

注意：一个线程被其他线程调用pthread_cancel取消的话，有一定的延迟性，即被取消的线程需要等线程达到某个取消点或者检查点才能被杀死。这些检查点通常是一些系统调用。如果线程没有取消点，那么我们可以自己来设置这个取消点，使用pthreestcancel函数，对于一个被取消的线程，使用pthread_join回收的时候,返回值是-1（PTHREAD_CANCELED的宏定义）。

------------------------------------------------------------------------------

#### 3.线程分离
线程分离：指的是线程和当前的主控线程等线程脱离关系（状态上分开），线程结束后其退出状态不由其他的线程获取，而直接自己释放。一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。在设置线程分离的时候可以使用如下函数

	#include <pthread.h>

       int pthread_detach(pthread_t thread);

#### 4.比较两个线程ID是否相等

 		#include <pthread.h>

       int pthread_equal(pthread_t t1, pthread_t t2);













