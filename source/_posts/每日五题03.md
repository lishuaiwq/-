---
title: 每日五题03
date: 2018-03-02 10:37:28
tags: 面试题
categories: 
- 面试题
- c/c++
---
## 问题1：c++中为什么有时候要用extern "C"
extern "C'的作用是：告诉C++编译器，我用extern "C"声明的函数，你给我当成C语言中的函数来处理，别走你的c++路线就可以了。为什么要这样呢？举个例子
<!--more-->
a.c文件内容如下：

    #include<stdio.h>
    int fun()
     {
        return 10;
     }
b.cpp文件内容如下:
  
	  #include<iostream>
    using namesapce std;
    extern int fun();//声明fun函数是外部的
    int main()
    {
      cout<<fun()<<endl;
      return 0;
    }
现在a.c文件的内容我照c编译器取去编译汇编生成二进制文件a.o(gcc -c a.c),下面我们来编译b.cpp文件

	g++ b.cpp a.o
我们会发现编译器会报错：错误内容是fun函数未定义，这是为什么呢？明明已经用extern声明了fun函数了还会报错。这就牵扯到了c++和c编译器对于函数的处理
c++因为其支持函数重载，所以c++编译器在对函数名处理的过程中需要结合其函数名，参数类型等生成一个独一无二的函数名，而c编译器就只是简单的处理了一下函数名就完了。
所以在上面的问题主要是c++编译器将b.cpp中的fun函数可能处理成了_fun_int_（假设）这种类型，而a.c中的函数被c编译器处理成了_fun这种类型，所以在连接的过程中b.cpp在a.c文件中只能找到_fun这个类型函数，和自己文件中的_fun_int_函数无法匹配，所以调用失败，所以显示的未定义。
这个时候extern "C"就闪亮登场了。用extern "C"在b.cpp中声明fun函数,像这样

	1 extern "C" int fun();
    2 extern "C"
     { int fun();}
两种形式都可以。那么c++编译器在处理b.cpp的时候就会把fun（）函数按照c语言的命名规则来处理，处理成_fun，这样的话刚好在a.c中找到了_fun，就可以调用成功了！这就是extern "C"的作用！

强调：

1.gcc -c a.c将a.c生成目标文件等着连接器连接呢会生成a.o

2. g++ b.cpp a.o
## 问题2：全局变量和局部变量的区别

有区别：全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。当一个c程序占用内存以下的几个部分

栈：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。

堆：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。

全局（静态）存储区:分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。

常量区：存放常量字符串。程序结束后由系统释放。

代码段：存放程序的二进制代码。
## 问题3:堆栈溢出一般由什么原因造成的
1.没有回收垃圾资源

2.递归层次太深

3.分配了超额的空间
## 问题4：什么函数不能声明为虚函数

首先先解释一下什么是虚函数，以及他的作用！然后再回答主问题

1.普通的函数，即不在类中。

因为普通的函数只能被重载，不能被继承，也不能被重写，在编译期间就绑定的函数，所以不能声明为虚函数，没意义。如果你 这样做了 ，编译器会告诉你声明无效！

2.构造函数

这个我上篇文章中就很详细的说明了这里就不多解释了

3.内联函数

inline函数在编译时被展开，用函数体去替换函数，而virtual是在运行期间才能动态绑定的，这也决定了inline函数不可能为虚函数。（inline函数体现的是一种编译机制，而virtual体现的是一种动态运行机制）

4.静态成员函数

静态成员函数是类的组成部分，但是不是任何对象的组成部分，所有对象共享一份，没有必要动态绑定，也不能被继承【效果能，但机理不能。静态成员函数就一份实体，在父类里；子类继承父类时也无需拷贝父类的静态函数，但子类可以使用父类的静态成员函数】，并且静态成员函数只能访问静态变量。所以不能为virtual。

5.友元函数

友员函数不是类的成员函数，C++不支持友员被继承，所以不能为virtual。

能是虚函数的条件：

1.是类的成员函数；

2.能被继承；

3.动态编译绑定，动态；迟联编译：

注意：空指针不能调用虚函数，因为虚指针在创建对象时创建，没有创建对象就没有虚指针，那么用空指针调用虚函数就会崩溃！！

 空指针可以调用成员函数，前提是该成员函数没有调用类的成员变量，因为指针只要拿到函数的入口地址就可以调用该函数，但是如果调用了成员变量，则因为找不到成员变量而崩溃！！！
学习自:[http://blog.csdn.net/gogokongyin/article/details/51121974](http://blog.csdn.net/gogokongyin/article/details/51121974 "http://blog.csdn.net/gogokongyin/article/details/51121974")
## 问题5：全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
可以！只能用static声明就行！因为用static声明的全局变量就会变成静态全局变量此时他的作用域仅限于定义它的源文件，其他源文件不可见所以不会引起命名冲突和重定义！不然的话全局变量可以在多个源文件中声明，但是只能在一个源文件中定义，不然的话就会引起变量重定义的错误！