---
title: static详解
date: 2018-02-25 13:15:28
tags: static
categories: c/c++
---
static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。
<!--more-->

作用：

1.限定作用域


2.保持变量的内容持久化

## 1.C语言中的static
### 1.修饰全局变量
当一个进程的全局变量被static修饰以后，它就可以成为全局静态变量，全局静态变量和其他的全局变量的存储地是一样的，都是在.data段（存放已经初始化了的全局变量）或者.bss段（存放未初始化的全局变量），具体在哪里取决于你有没有初始化这个全局变量。在这里static的作用就是限定作用域了，即被修饰的全局变量只能在定义它的源文件内有效，其他源文件无法访问。

举例如下：



.h文件
 
	#include<stdio.h>
	extern int a;//声明全局变量
	void fun();//声明函数
b.c文件

    b.c文件
	#include"head.h"
	static int a = 10;//静态全局变量，放在了.data段
	void fun()
	{
	printf("%d\n", a);
	}
a.c文件	

	#include"head.h"
	int main()
	{
	printf("%d", a);
	return 0;
	}
在上述例子中，a.c文件无法使用源文件b.c的被static修饰的全局变量，编译会报错！但是如果在a.c中调用fun函数，在这个函数中使用a就可以，因为其作用域就在其定义的源文件，所以被自己的源文件内的函数访问是没有问题的。
### 2.修饰局部变量

被static修饰的局部变量会被放在.data段，注意这里不是在.bss段，所以这个变量的生命周期在整个程序的生命周期中存在，尽管被放在.data段，但是同样它也只能被自己作用域内的函数或者变量所访问，不能被外界访问。同样static在这里的作用相当于改变了局部变量的生命周期。注意这里解释一下为什么放在了.data段，因为如果用户没有初始化的话，编译器会自动给其赋值0，所以放在了.data段。所以以后每次调用这个变量的时候相当于一直读取同一位置的这个变量，在这里注意和局部变量区别开来。
就是因为这一特性，内含静态局部变量的函数是不可重入函数。

b.c文件

	#include"head.h"
	void fun()
	{
	static int a;
	printf("%d\n", a++);
	}
a.c文件

	#include"head.h"
 	int main()
 	{
	fun();
	fun();
	fun();
	getchar();
	return 0;
	} 
这样的输出结果是0 1 2.

### 3.修饰函数
这里static的作用也是限定了函数的作用，使被static修饰的函数不能被其他源文件所调用。这里很简单的就不举例子了。static函数可以很好的解决不同源文件中的函数重名的问题，因为每个函数的名字仅自己可见，肯定不会发生冲突的！

## 2.C++中的static
C++的中的static关键字主要要讲的就是其修饰的成员变量和成员函数。

### 1.static修饰成员变量
当一个类的成员变量被static关键字修饰以后就变成了静态数据成员了，静态数据成员有一下特点：

1.静态数据成员是类的成员而非对象的成员，它对于所有的对象是共享的，即无论对象被定义了多少个这个静态的成员只有一份，即只分配一次内存，这一样某种程度来说还节省了空间

2.静态成员存储在全局数据区，静态成员在定义的时候要分配空间，所以不不能再类声明的时候定义，需要在类外使用如下形式定义

int myclass::a=0;

3.静态成员同样遵守三个访问限制，同时即使不定义类对象也可以对它进行操作

4.静态成员的作用就是在多个对象拥有同一个属性的时候，使用它可以方便操作，改变一次就全部改变，使用静态数据成员也不存在和其他全局变量的名字冲突，因为其有访问限制属性所以可以实现信息隐藏。

## 2.static修饰成员函数
1.同样静态成员函数也是被所有对象共享，并且他没有this指针，所以他不能访问成员函数和成员变量只能访问静态成员函数和静态成员变量，但是非静态成员函数可以访问静态成员函数和静态变量

2.因为没有this指针，其速度相对于成员函数来说会快一些

3.调用静态成员函数的方式和调用静音胎成员的方式差不多，可以使用.，->和::
