---
title: 每日五题04
date: 2018-03-04 08:59:53
tags: 面试题
categories:
- 面试题
- c/c++
---
## 问题1：指针和引用的区别
1.引用在定义的时候必须被初始化，而指针不用必须被初始化

2.引用初始化以后不能改变其引用对象，指针可以改变

3.不存在指向空值的引用，但是存在指向空值的指针
<!--more-->
4.sizeof引用得到的是所指对象的大小，sizeof指针得到的是指针变量的大小和其指向的内容没有关系

5.指针和引用的自增运算意义不一样

6.引用的创建和销毁不会调用构造和析构函数

7.指针可以有多级，而引用只有一级

8.引用实质也是指针，const int *p=&a，只不过这个工作是编译器帮我们做的 

下面附上我关于引用的博客：[http://blog.csdn.net/it_iverson/article/details/76832741](http://blog.csdn.net/it_iverson/article/details/76832741 "http://blog.csdn.net/it_iverson/article/details/76832741")
## 问题2：for(;1;)有什么问题？
这是一个死循环，for中两个分好中间为判断条件，为真则执行。这里为1，相当于true，也就是死循环。等价于for(;;)也等价于while(1)。

那么下面来说说for(;;)和while(1)的区别

1、 for（；；）死循环里的两个；；代表两个空语句，编译器一般会优化掉它们，直接进入循环体。 
while（1）死循环里的1被看成表达式，每循环一次都要判断常量1是不是等于零。 
即，相对来说for式死循环更加高效一点 
当然以上条件成立还要看编译器的优化，一些编译器优化的两者并无区别，但是，并非所有的编译器都做了这样的优化。 

2、for（；；）只有7个字符和while（1）相比省一个字符 

## 问题3：用宏定义写swap(x,y)

	#define Swap(x,y) (x)=(x)+(y);(y)=(x)-(y);(x)=(x)-(y)
	#define Swap(x,y) (x)=((x)^(y));(y)=((x)^(y));(x)=((x)^(y))
## 问题4：关键字const 和volatile
[http://blog.csdn.net/it_iverson/article/details/78488249](http://blog.csdn.net/it_iverson/article/details/78488249 "http://blog.csdn.net/it_iverson/article/details/78488249")
这篇博客是关于const的详解
下面说说volatile

 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存

当一个 变量被const和volatile同时修饰的时候：

主要要搞清楚 编译期 和 运行期的关系。 
编译期就是 C 编译器将 源代码转化为 汇编再到机器代码 的过程。 
运行期就是 实际的机器代码在CPU执行 的过程。很多书上说的东西，其实都只是指编译期进行的事情。const 和 volatile 也一样，所谓的 const ，只是告诉编译器要保证在 C的“源代码”里面，没有对该变量进行修改的地方，就是该变量不能而出现在赋值符号左边。实际运行的时候则不是 编译器 所能管的了。同样，volatile的所谓“可能被修改”，是指“在运行期间”可能被修改。也就是告诉编译器，这个变量不是“只”会被这些 C的“源代码”所操纵，其它地方也有操纵它们的地方。所以，C编译器就不能随便对它进行优化了 。所以每次读它要在它内存中读，不要在寄存器中读备份。

## 问题5：struct和class的区别
首先c++中对于struct进行了极大的改进和优化。下面我们来讲讲其和class的区别
1.首先是对于默认访问权限的 区别。class如果不写的话就是私有，而struct是public的，c++中的struct也可以继承，实现多态，包含成员函数。所以class和struct可以混合继承，但是这里的继承权限取决于子类是struct还是class ,如果子类是 class 并且没有写继承权限的话就是私有继承，如果是struct并且没有写继承权限的话就是私有继承。

2.class可以用于定义模板参数，而struct不行

3.struct可以默认使用{}初始化，而class不行，因为其默认访问权限是private的,所以将其默认权限改成public的话class也可以使用{}。但是如果给struct加入构造函数，则struct也不能使用{}初始化了。