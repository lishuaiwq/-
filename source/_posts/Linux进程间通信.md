---
title: Linux进程间通信(IPC)
date: 2018-03-22 21:48:23
tags: 进程间通信
categories:
- Linux
- 系统编程
---
关于进程间通信就不多说了，接下来对于Linux间的进程通信的一些方式进行介绍，主要方式有下面的几种

- 管道
- 消息队列
- 共享内存
- 信号量

在这里要说要一下我们这里的消息队列、共享内存、信号量是System V版本下面的IPC，注意和POSIX区别。下面我来一个一个详细介绍

<!--more-->

## 一.管道
管道是UNIX系统IPC的最古老的方式，所有UNIX系统都提供这种通信机制。
管道分为匿名管道(pipe)和命名管道(fifo)
### 1.匿名管道
：作用于有血缘关系的进程间通信，完成数据的传送，调用pipe系统函数即可创建一个匿名管道。
	
	#include<unistd.h>
	int pipe(int pipefd[2])
正确返回0，错误返回-1，并且设置errno值。

- 其本质是一个伪文件（实质是内核的一个缓冲区）
- 有两个文件描述符引用，一个表示读端，一个表示写端
- 规定数据从管道的写端流入管道fd[1]，从读端流出管道fd[0]
- 采用半双工通信方式，即数据同一时刻只能在一个方向上流动


一般情况下一个进程先会调用pipe，然后调用fork(),从而创建从父进程到子进程的IPC通道。fork之后对于数据的流向取决于我们。如果我们想让父进程写数据，则将父进程的读端关闭，即关闭fd[0]，将子进程的写端关闭fd[1]，反之亦然。

![](https://i.imgur.com/FtkvlPm.jpg)

我们进行相应端的关闭就可以进行通信了

![](https://i.imgur.com/DTNhikD.jpg)

对于管道最后有几点要强调的：

1.如果写端文件描述被关闭，则读端返回0

2.如果读端被关闭，则写端会产生信号SIGPIPE，写端进程结束

3.当要写入的数据不大于PIPE_BUF时，linux将保证写入的原子性，如果大于PIPE_BUF时，则不保证其写入的原子性。

4.一般而言进程退出，管道释放，所以管道的声明周期随进程。

### 2.命名管道

对于匿名管道的应用有个限制就是只能应用于有血缘关系的进程，而命名管道恰好弥补了这个缺点，可以在两个不相干的进程间通信。

创建匿名管道的方式有两种：

1.命令创建，使用mkfifo fifoname,这就创建了一个名字为fifoname的命名管道,然后两个进程分别打开这个文件就可以通信了

2.使用mkfifo函数打开。

	#include <sys/types.h>
    #include <sys/stat.h>

     int mkfifo(const char *pathname, mode_t mode);
成功返回0，失败返回-1，并设置errno。

命名管道的打开方式和打开的时候的一些问题这里强调一下：

----------------------------------------------------------------------------

1.如果没有设定open FIFO的O_NONBLOCK权限的话，那么当前打开的操作默认是会产生阻塞，即是读打开的FIFO的话，如果此时没有进程以写的方式打开同一个FIFO文件的话，那么当前进程阻塞，直到有进程以写的方式打开同一个FIFO，反之亦然！

2.如果open FIFO的时候指定了 O_NONBLOCK则不阻塞。但是会产生一些问题。


如果是写进程设置了不阻塞，但是当写进程运行了时候没有于之对应的读进程运行的话，那么这个写进程的open操作会立马返回失败，错误号为ENXIO(6)，使用errno全局变量可以打印出来。

如果是读进程设置了不阻塞，运行时没有写进程与之对应，则读进程open成功，只不过以读取值为0而退出。

所以一般情况下，就默认阻塞就可以了。。。免得产生一堆麻烦

-----------------------------------------------------------------------


对于设置了阻塞标志的写操作：

当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。
当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。

对于没有设置阻塞标志的写操作：

当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在写满所有FIFO空闲缓冲区后，写操作返回。
当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写；

-------------------------------------------------------------------------------
对于运行时的一些操作：

如果两个进程正在进行读写操作，这个时候读端关闭了，那么写端再写的话，写进程会产生一个SIGPIPE（13）的信号，意思是写入没有读端的操作，那么会将写进程终止掉。自己可以去捕捉验证。
如果是写进程先关闭的话，那么会给读进程产生一个文件结束标志，即读进程以读取值为0方式退出！

（划重点了！考试要考！注意共享资源printf的刷新fflush(stdout)，不然会影响两边的输出,切记！！！！，还有FIFO也是半双工，想要互相通信的话那么记得创建两个fifo来通信）

关于fifo的使用自己去练习吧，这里就不贴多余的代码了。

## 二.消息队列
消息队列是消息的链表，存储在内核中，由消息队列标识符标识！它是内核给我们提供的一种IPC的方式。
首先给出一个大概的示意图

再来看看系统为我们维护的消息队列的结构

在/usr/include/linux/msg.h中查看
![](https://i.imgur.com/edIYwxb.jpg)
对于结构体中的第一个结构体ipc_perm在这里

在这里查看/usr/include/linux/ipc.h

![](https://i.imgur.com/YRKFTXt.jpg)

所以说系统大概是 这么维护我们这个消息队列的！
![](https://i.imgur.com/0uTeJX0.jpg)


先简单概括一下怎么使用消息队列吧：

1.得到_key,用来生成一个唯一的消息队列的秘钥，然后得到一个消息队列的标识符，用这个标识符来进行相关操作。下面来介绍一些关于消息队列的使用函数。

--------------------------------------------------------------------------------
#### 1.获取_key的函数

	#include <sys/types.h>
    #include <sys/ipc.h>

    key_t ftok(const char *pathname, int proj_id);

ftok的功能就是由一个路径名字和项目ID产生一个key。

参数：

pathname:就是你自己指定一个文件名（已经存在的文件名），一般情况用当前目录。（.）

proj_id:是1-255之间的字符值,不能取0值

man文档的描述：

ftok（）函数使用由给定路径名命名的文件的标识（它必须引用现有的，
        可访问的文件）和proj_id的最低有效8位（它必须是非零）来生成key_t类型
        System V IPC密钥，适用于msgget（2），semget（2）或shmget（2）。

其返回值成功我们的秘钥，失败返回-1，这样通过这个函数就得到了_key.

---------------------------------------------------------------------------------

#### 2.创建消息队列

	#include <sys/types.h>
    #include <sys/ipc.h>
    #include <sys/msg.h>

    int msgget(key_t key, int msgflg);

参数：

1.key就是我们的秘钥

2.生成消息队列的一些权限和打开文件时的一些权限是一样的一般来说取IPC_CREATE、IPC_EXCL。如果想要创建一个新的消息队列，并且确保这个消息队列独一无二，则msgflag设置成IPC_CREATE | IPC_EXCL,这样的话当有重复消息队列的时候就会报错返回EEXIST。

成功返回消息队列的表示符，可以理解为我们创建的消息队列的名字，失败返回-1，设置errno

在这里一般情况是服务器进程创建消息队列，客户端进程只要拿到消息队列的标识符就可以和服务器通过消息队列通信

---------------------------------------------------------------------------------
#### 3.消息队列的控制函数

	#include <sys/types.h>
    #include <sys/ipc.h>
    #include <sys/msg.h>

   	int msgctl(int msqid, int cmd, struct msqid_ds *buf);
																	成功返回0，出错返回-1

参数：

1.msqid：就是我们通过msgget获得的消息队列的标识符，用这个标识符就可以操作消息队列。

2.cmd:表示对我们要操作的消息队列要进行的操作，有三个取值

- IPC_STAT: 将与msqid相关联的内核数据结构的信息复制到指向的msqid_ds结构中buf中。调用者必须具有消息队列的读取权限

- IPC_SET:将与msqid相关联字段中的某些值，设置为buf所关联的消息队列中的值。执行此命令的进程需要一定的权限限制

- IPC_RMID：从内核中删除消息队列及其所有的数据。这种删除立即生效。删除后扔在使用此消息队列的进程对消息队列再次进行操作的时候，将得到EIDRM错误。这个命令的执行也需要进程有一定的权限。
（这三个操作同样也可以用于信号量和共享内存）

3.buf就是我们自己定义的结构体

--------------------------------------------------------------------------------
#### 4.往消息队列中放消息

		#include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
                                                     成功返回0，出错返回-1
在说这个函数之前，我们来看一下发送的消息的类型


![](https://i.imgur.com/tmZTrTF.jpg)

是一个结构体里面的内容分别是消息的类型和消息的内容。消息的类型用来判断是客户端发的还是服务器发的，因为二者都在同一个消息队列中放数据不区别的话，很容易搞乱的！

下面来看msgsnd的参数

1.msqid：消息队列的表示符

2.msgp:传入参数，表示指向我们所发送的消息，即上图中的消息的结构体类型

3.msgz:消息的长度，这个长度不包括结构体中消息类型的长度，仅仅是数据的长度

4.msgflg:控制着当前消息队列满或者到达系统上限时的处理方法。

magflg=IPC_NOWAIT:表示如果队列中的消息总数等于系统的限定值（消息结构体个数），或者消息队列中总的字节数等于系统限制，则立即出错返回EAGAIN.

如果没有指定magflg=NOWAIT的话，那么消息队列满了的话，则会一直阻塞到有空间可以容纳消息或者从系统中删除了这个消息队列或者收到某个信号，从信号处理返回程序。没有设置NOWAIT会返回EIDRM错误（消息队列被删除）或者返回EINTR错误（信号）

如果将消息队列删除了，那么再使用这个消息队列的进程会出错返回。

当msgnd函数成功返回的时候，msqid_ds中的内容会随之更新。

--------------------------------------------------------------------------------
#### 5.从消息队列中取消息

	#include <sys/types.h>
    #include <sys/ipc.h>
    #include <sys/msg.h>

    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);


参数：

1.msqid:消息队列的标识符

2.msgp:指向我们自定义用来接收消息的结构体(传入传出参数)

3.msgz:消息的长度，这个长度不包括结构体中消息类型的长度，仅仅是数据的长度

4.msgtyp:表示读取消息时候的一些优先级。

msgtype==0,返回消息队列中的第一条消息

msgtype>0,返回消息队列中类型为msgtype的第一条消息（就是找我们指定的消息）

msgtype<0,返回消息队列中类型值小于msgtype的绝对值的消息，如果这种消息有很多，则返回其中类型值最小的。（我觉得一般多个进程使用一个消息队列通信才会用到）

5.msgflg:如果队列中没有对应类型的消息将会发生的事

msgflg=IPC_NOWAIT,没有对应消息的时候不等待，返回ENOMSG错误

msgflg=MSG_NOERROR,消息大小超过magsz时被截断

msgflg=MSG_NOERROR并且msgtype>0，接收类型不等于msgtype的第一条消息。

---------------------------------------------------------------------------------

## 三.共享内存

先用一张图来解释吧

![](https://i.imgur.com/mahNKSq.jpg)

共享内存就是一块物理内存可以映射到多个继承的共享区，那么每个进程都可以访问这块共享区，而且一个进程对这块区域的数据进行了了修改的坏，那么其他的进程都能看见，这就不需要将数据在两个进程之间复制来复制，不用进入内核，而直接实现通信，所以这是IPC最快的通信方式，但是只要多个进程对于共享区访问，就会出现同步互斥的问题，这是我们在使用共享内存唯一需要注意的地方，当然这个问题可以使用互斥锁和信号去解决。下面我们先来看看怎么使用共享内存实现进程间的通信。


首先系统为内存的你要的那块共享区域维护着一个数据结构
在/usr/include/linux/shm.h中查看
![](https://i.imgur.com/NZSDi5j.jpg)

我们同样可以看到个数据成员是ipc_perm，则说明我们想要创建一个共享内存则也需要一个独一无二的秘钥，即需要使用ftok函数。

#### 1.使用ftok获取key秘钥

#### 2.创建共享内存

	   #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmget(key_t key, size_t size, int shmflg);
                                               成功返回共享内存标识符，失败返回-1
参数：

1.key：用来创建共享内存的秘钥

2.size:共享内存的大小，以字节为单位

3.shmflg：创建时的一些权限比如IPC_CREAT、IPC_EXCL

#### 3.将共享内存段连接到进程的虚拟地址空间

		#include <sys/types.h>
        #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);
                           成功返回一个指针，指向共享内存的第一个字节（共享区的内存），失败返回-1
参数：

1.shmid:共享内存的标识符（物理内存）

2.shmaddr:指定连接的地址，即自己定义在虚拟内存中的地址，但是其又和shmflag参数有关系

3.shflag:其有两个取值，SHM_RND（表示取整的意思）或者SHM_RDONLY（只读）

当shmaddr==NULL,核心自动选择一个地址,用返回值返回

当shmaddr!=NULL,并且shflag没有设置SHM_RND标记，则以shmaddr为连接地址

当shmaddr!=NULL,且shmflag设置了SHM_RND标记，则连接的地址会自动向下调整为SHMLBA的整数倍。（公式：shmaddr-(shmaddr%SHMLBA)），SHMLBA意思是“低边界地址倍数，总是2的乘方”。

当shflag==SHM_RDONLY,表示连接操作用来只读共享内存，不具备写的操作。否则具备读写的权限。

一般情况下都将shmaddr设置为0，由系统去选择地址。如果shmat调用成功，则shmid_ds结构中的计数器+1。如果一个进程使用完了共享内存，则应该调用shmdt将其映射关系分离，那么shmid_ds中的计数器就会-1，但是这个分离操作并不会删除我们之前在内存中创建的共享内存，这需要我们手动去删除。

#### 4.将共享内存段与当前进程脱离关系

	#include <sys/types.h>
    #include <sys/shm.h>

	int shmdt(const void *shmaddr);
                        成功返回0，失败返回-1
参数：

shmaddr:建立的连接地址，即由shmat返回的地址。特别注意脱离关系不代表删除了共享内存。

#### 5.用于控制共享内存（内存中的共享内存）

		#include <sys/ipc.h>
       #include <sys/shm.h>

       int shmctl(int shmid, int cmd, struct shmid_ds *buf);
                                      成功返回0，失败返回-1
参数：

1.shmid：共享内存的标识符

2.cmd:将要采取的处理动作，有三个值。

3.自己定义的struct shmid_ds *buf结构体

当cmd==IPC_STAT：把自定义shmid_ds结构中的数据设置为共享内存当前的关联值

当cmd==IPC_SET:把共享内存的 shmid_ds设置为自定义的 shmid_ds的值

当cmd==IPC_RMID:删除共享内存。因为shmid_ds中的shmid_nattch是一个计数器，所以当使用该共享内存的最后一个进程删除，否则不会真的删除。

## 四.信号量

信号量其实是一个计数器，用来完成多个进程访问共享资源的同步互斥问题。（即让每个进程有条理的访问共享资源，而不会出现混乱访问），其本身并不具有传递数据的功能，出现在这里只是以为了说明使用共享内存访问的一些问题。但是信号量也是临界资源。多个进程可以访问的，所以算是进程间通信的一种，只不过没有其他的 几种方式那么严格罢了。

这里对于一些概念的解释：

临界资源：不同进程访问的同一资源称为临界资源。

临界区：访问访问临界资源的代码

同步：有顺序的取执行

互斥：同一时刻只能有一个进程访问临界区。

因为说信号量本质是一个计数器，所以其伴随着两个原子操作（这种操作中间不会失去时间轮片，瞬间完成的），P操作和V操作。
我们给出信号量结构体的伪代码

	struct semaphore
	{
  	int value;
  	poniter_PCB queue;
	}

P操作：

	p(s)
	{
 	 s.value=s.value--;
     if(s.value<0)
     {
        该进程的状态设置为等待状态
        将该进程的PCB插入信号量结构体的等待队列中s.queue
      }

V操作

	p(s)
    s.value=s.value++;
    {
       唤醒等待的队列s.queue中一个等待的进程
       改变其状态为就绪，将其插入就绪队列准备运行 
    }

操作系统为我们维护了一个信号量集

在/usr/include/linux/sem.h中查看
![](https://i.imgur.com/Ob6BFRW.jpg)

由此我们可以看到想得到一个信号量集，也需要我们用秘钥key取去获得！

下面 就来介绍一下关于信号量集和信号量的一些操作函数,如何获得秘钥key这里就不多说了

--------------------------------------------------------------------------------
#### 1.创建一个信号量集

		#include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semget(key_t key, int nsems, int semflg);

参数：

1.key:秘钥

2.信号集中信号量的个数

3.创建信号量集时候的一些参数IPC_CREAT 、IPC_EXCL

---------------------------------------------------------------------------------
#### 2.对于信号量集做的一些操作

	   #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semctl(int semid, int semnum, int cmd, ...);

参数：

1.semid:信号量集的标识符

2.semnum:要操作哪个信号量

3.cmd:将要采取的措施。

4...：主要取决去cmd要执行什么动作，这里就需要一个联合体了

![](https://i.imgur.com/xoC9qGv.jpg)

因为根据cmd不同的动作，我们都要使用到联合体中的一个成员变量。

当cmd==SETVAL的时候,使用val设置对应的信号量的计数值。

当cmd==GETVAL的时候获取信号量集中对应信号量的计数值

当cmd==IPC_STAT把联合体中semid_ds结构体的值设置为当前信号集的值

当cmd==IPC_SET把当前信号集的值设置为自己定义的semid_ds的值

当cmd==IPC_RMID删除信号集

---------------------------------------------------------------------------------

#### 3.对信号量集的信号量进行操作(PV操作)

		#include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semop(int semid, struct sembuf *sops, unsigned nsops);

参数：

1.semid:信号量集的标识符

2.sops:对应一个strutc sembuf*

3.nsops：信号集中信号量的个数

其中struct sembuf的结构是

	struct sembuf
    { 
       short sem_num;
       short sem_op;
       short sem_flag;
    }

num:表示信号量的编号

sen_op:取-1，表示p操作--(表示获取信号量控制的资源)，取+1，v操作（表示释放该信号量控制的资源）

sem_flag:一般来说取IPC_NOWAIT或者IPC_UNDO。详见unpe458页。


--------------------------------------------------------------------------------

好了关于Linux的进程间通信的一些方法就说完了，当然这里讲的是共享内存，还有一种通信方式是内存映射，即借助同一个文件在不同进程的共享区映射一个区域，当进程在这个区域进程操作 时，相当于在文件中操作，也可以进程通信，这个就需要使用mmap()函数，当然关于这种通信方式也在我的CSDN博客中介绍了。感兴趣的可以了解一下 内存共享和内存映射的区别
[https://blog.csdn.net/it_iverson/article/details/79303567](https://blog.csdn.net/it_iverson/article/details/79303567)

还有进程间也可以直接借助文件来进行通信！

关于本篇博客中进程间通信方式的联系源代码已经上传至github

[https://github.com/lishuaiwq/linux_ipc](https://github.com/lishuaiwq/linux_ipc)

如果博客中有什么不对的地方希望大家提出来！






