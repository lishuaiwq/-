---
title: c陷阱与缺陷
date: 2018-02-25 23:10:39
tags: c陷阱与缺陷
categories: 读书笔记
---
## 1.词法陷阱
1.注意不要讲=和==混用，还有&和&&是两回事，这个自己都要搞清楚。
<!--more-->

2.词法分析使用的是贪心法，即读取一个字符以后，如果该字符可能组成一个符号，则继续读入下一个 字符，然后判断两个字符组成的字符串是否可以是一个符号的组成部分，如果是则继续读入依此类推。

3.用单引号引起来的一个字符实际上表示一个整数，整数值对应其ascii的值。而双引号引起来的字符串表示的是一个指向无名数组起始字符的指针，该数组被双引号引起来的字符和一个额外的'\0'初始化

4.用int a='abc',则a的值是616263即每个字符对应的ascii的序列，用char a='abc'，则a的值是c。即c将ab覆盖

5.a+++++b的解释，词法分析的贪心算法可以解得为a ++ ++ + b即((a++)++)+b,但是a++不能当左值，所以这应该是个错误的写法。
## 2.语法陷阱
1.

	(*(void(*)())0)()
将0转换为函数指针（这个函数指针返回值为void参数为空），然后再调用这个函数.
用typedef比较好理解

	 typedef void (*funcptr)();
     (*(funcptr)0)(); 
2.

	(void)(*signal(int,void(*)(int)))(int);
signal的参数是整形和函数指针,返回值也是函数指针。用typedef比较好理解

    typedef (void ) (*handler)(int);
    handler signal(int,handler);

3.else总是和同一对括号内最近的未匹配的if相结合。
## 3.语义陷阱
1.如果我们在该使用指针的，确使用了数组名来替换，那么数组名就被当做指向该数组下标为0的元素的指针，所以我们可以这样写

	int arr[]={1,2,3};
	int *p=arr;//没有任何问题
注意在上述代码中我们并没有写成如下形式
 
	int *p=&arr;
其实这是不合法的操作，因为其类型不匹配，&arr表示整个数组的指针其类型是int[3]*,所以如果你这么写了可能会被视为非法也可能被视为和p=arr一样的操作。

要强调的是：数组名除了在sizeof中以外，其余的所有情形都表示数组下标为0的元素的指针。

（上述问题的背景还限于一维数组，下面我们来讨论一下二维数组）

二维数组其实也是由一维数组组成的，只不过这个一维数组中的每个元素都是一个一维数组。
所以如果你这么赋值是不对的

	int arr[][3]={1,2,3,4,5,6,7,8,9}
	int *p=a;错
	int **p=a;错
因为a表示数组下标为0的元素的指针，因为其实二维数组，其下标为0的元素也是个数组，所以a的类型就是int (*)[3],类型不兼容的！如果你这么使用了，虽然可能会通过编译，那么将失去了二维数组的意义
，就是将二维数组变成了一维数组。
我们正确的方式应该是这样的

  	int (*p)[3]=a;

2.对于指针的复制并不是复制指针的内容，而是使两个指针指向同一块区域，还有就是对字符串常量的修改是非法的！不能对空指针解引用！即使输出空指针的内容也是不合法的！

3.关于数组越界的无限循环问题

	int i, arr[10] = {0};
	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("hello\n");
	}
此代码会无限输出hello,原因如下
![](https://i.imgur.com/4isVrdE.jpg)
## 4.连接
1.连接器：就是想编译汇编产生的若干目标模块，整和成一个被称为载入模块或者可执行程序文件的实体，该实体可以被操作系统直接执行。并且会检查是否有重命名的函数和变量。

2.为了避免发生不必要的麻烦，每个外部变量在所有源文件中只能定义一次。

3.使用static可以防止不同源文件的命名冲突问题，因为它限制了变量的作用域。
