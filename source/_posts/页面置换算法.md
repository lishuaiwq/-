---
title: 页面置换算法
date: 2018-05-08 19:22:49
tags: 存储
categories: 系统学习

---

## 1.页面置换算法的概念

功能：当出现缺页异常，需要调入新的页面内存已经满时，置换算法选择被置换的物理页面
<!--more-->
设计目标：

1.尽可能的减少页面的调入调出次数

2.把未来的不在访问的或者短期内部访问的页面调出（这里的核心难点就在于如何知道未来不经常访问的页面呢）

注意：在说置换算法算法之前强调一点，就是页面锁定，即一些页面被锁定以后不能被置换到外存里面去，这些页面一般是描述常驻内存的逻辑页面，或者操作系统关键部分，或者是要求相应速度的代码和数据，只需要在对应的页表中将其锁定标志位置为1就可以了

## 2.局部页面置换算法

### 1.最优页面置换算法（OPT）

基本思路：置换在未来最长时间不访问的页面。

算法实现：缺页的时候，计算内存中每个逻辑页面的下一次访问的时间，然后选择未来最长时间不访问的页面置换出去

算法的特征：

1.缺页最少

2.实际系统中无法实现

3.无法预知每个页面在下一次访问前的等待时间。

既然这个算法在实际系统中无法实现为什么我们还要说这个算法呢？

因为我们可以根据这个算法来衡量其他设计的算法的性能，比如我们模拟某个程序运行，第一次记录每个页面的访问时间，第二次不就可以使用最优算法了。

下面给出算法的模拟实现图：

![](https://i.imgur.com/Jm5c9OB.jpg)


### 2.先进先出算法（FIFO）

思路：

选择在内存中驻留时间最长的页面进行置换（驻留的时间越长不就是最先进来的嘛）

实现：

维护一个记录所有位于内存中的逻辑页面的链表，链表中的结点按驻留在内存中时间排序（时间最长的在链表头部，时间最短的在链表尾部），当出现缺页的时候，选择链表头部页面进行置换，新的页面添加到链尾。

特征：

实现简单；性能较差，调出的页面可能是经常访问的页面；进程分配物理页面数增加的时候，缺页不一定会减少（Belady现象）；很少单独使用，一般和其他算法一起使用。

![](https://i.imgur.com/yKA8cxL.jpg)
### 3.最近最久未使用算法（LRU）

思路：选择最长时间没有被引用的页面进行置换，如果某些页面长时间未被访问，则他们在将来可能还会长时间不会被访问。

实现：缺页时候，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面

特征：最优置换算法的一种近似。

![](https://i.imgur.com/VMo8vPn.jpg)

实现LRU的可能的手段

1.页面链表

系统维护一个按最近一次访问时间排序的链表，链表的首结点是最近刚刚使用的页面，链表尾结点是最久未使用的页面。

当访问内存的时候，找到相应的页面，并把他头插入结点，缺页时直接置换尾结点。

2.活动栈页面

访问页面的时候，将此页号压入栈顶，并将栈内相同页号抽出，缺页时，置换栈低的页面。

### 4.时钟页面置换算法（Clock）

这个算法是FIFO和LRU算法的结合。

思路：仅对页面的访问情况进行大致统计。

数据结构：

在页表的表项中增加访问位，描述页面在过去的一段时间内的访问情况。

各页面组成形成环形链表，指针指向最先调入的页面  

算法：

访问页面的时候，在页表项纪录页面访问情况，缺页的时候，从指针处开始顺序查找未被访问的页面进行替换。

算法的实现：

页面装入内存的时候，访问位初始化为0，访问页面（读/写）时，访问位置1，缺页的时候。从指针当前位置顺序检查环形链表。当访问位位0，则置换该页面，访问位为1.则访问位置0，并指针移动到下一个页面，直到找到可置换的页面。

下面给出时钟置换算法图示的演示图

![](https://i.imgur.com/qLdWOO3.jpg)

![](https://i.imgur.com/qmBqP8M.jpg)
特征：时钟算法是LRU和FIFO的折中

这个算法的缺点是，如果置换的页被修改过的话，那么还需要将修改过的页面保存，在进行替换，会比较低效，所以我们对这个算法进行改进

![](https://i.imgur.com/byOUHC9.jpg)
### 5.最不常用算法（LFU）
也是对LRU的一种简化的算法

思路：缺页的时候置换过去时间内访问次数最少的页面

实现：每个页面加一个访问计数，访问页面的时候访问计数+1，缺页时，置换计数最小的页面

不过这个算法有个问题，就是一个页面可能被置换进来还没访问几次就又被置换出去了。但是有一个解决办法就是：对已经计数的计数值较大的呢，定期右移，即将计数较大的页面会计数减小增加置换出去的概率

LRU和LFU的区别

LRU关注多久未访问，时间越短越好
LFU关注次数，这个更好的维护实现

致此局部置换算法就算描述完了，那么下面来讨论一下局部置换算法的一些相关问题

### 6.Belady现象
现象：采用FIFO等算法时，当进程缺页次数比较大时，就要给其增加物理页面，但是可能出现分配给进程的物理页面增加，那么他的缺页率反而会增加的现象。

原因：FIFO算法法的置换特征与进程访问内存的动态特征所矛盾，即依照置换特征被置换出去的页面，近期可能又会被访问。但是LRU就没有Belady现象。

### 7.LRU、FIFO和CLock的比较

 1.LRU和FIFO本质都是先进先出思路

LRU依据页面最近访问时间排序，LRU需要动态的调整顺序，FIFO依据页面进入内存的时间排序，FIFO页面进入时间是固定不变得。

LRU可退化成FIFO：比如页面进入内存后没有被访问，最近访问时间与进入内存的时间相同。
![](https://i.imgur.com/szUyTzK.jpg)
