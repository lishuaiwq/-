---
title: 网络01
date: 2018-04-28 16:55:17
tags: 网络
categories: 
- 面试题
- 网络
---
## 问题1：TCP为什么需要三次握手四次断开？

答：1.需要三次握手是为了：防止已经失效连接请求得报文段突然又传送到了服务器端，因为产生错误。
这里所产生的的错误会导致服务器端陷入等待，虽然有保活计时器，但是也会浪费资源呀（这种错误是两次握手导致的结果）。
<!--more-->
下面详细解释一下为什么会产生这种错误：如果是两次握手的话那么相当于客户端发送SYN给服务器，然后服务器回送SYN+ACK以后服务器就会以为自己和客户端建立了连接，所以问题就来了，如果客户端第一次的SYN请求报文阻塞了，那么根据超时重传机制，那么会发送第二个SYN，第二次成功建立并且顺利完成数据交付并结束连接，这个时候第一个阻塞的报文到达了服务器端、那么服务器端就认为客户端又要和自己建立连接，这个时候发送SYN+ACK以后，服务器端就认为已经建立了连接，但是客户端并没有发送SYN，所以不会理会服务器端的 ，那么服务器就傻傻的等待客户端发送数据，是不是造成了一种资源的浪费。

还有比如采用两次连接的话，只要服务器端发送SYN+ACK，服务器端就建立了连接，那么如果服务器的SYN+ACK丢失了，服务器还是建立连接，客户端重发SYN，服务器又建立连接，这样会很浪费资源的。

如果建立连接换为4次的话，其实是可以的，即将服务器端收到客户端的SYN以后发送SYN+ACK拆成两步，只不过这么做有点多余。。。

2.需要四次挥手是因为：TCP是一个全双工的通信协议，即允许允许同时通信的双方同时进行数据的收发，同样也允许收发两个方向的连接被独立关闭，以避免client数据发送完毕，向server发送FIN关闭连接，而server还有发送到client的数据没有发送完毕的情况。也就是因为其有个半关闭的状态！

## 问题2：TCP和UDP有什么区别？

答：对于这个问题可以从三个方面来回答，1.最基本的一些区别，2.应用场景的区别，3.socket编程上面的区别。下面我来一个一个阐述

1.基本的区别：TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。通信双方彼此交换数据前，必须先通过三次握手协议建立连接，之后才能传输数据。TCP提供超时重传，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。UDP是用户数据报协议，是一个简单的面向无连接的协议。UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDP的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序UDP不提供可靠的服务。在数据数据前不用建立连接故而传输速度很快。所以TCP报文设计要比UDP复杂的多。
[http://lishuaii.top/2018/03/29/UDP%E6%A6%82%E8%BF%B0/](http://lishuaii.top/2018/03/29/UDP%E6%A6%82%E8%BF%B0/)

这里给出UDP的介绍
2.应用场景：1.面向数据报方式，网络数据大多为短消息，拥有大量Client，对数据安全性无特殊要求
 ，网络负担非常重，但对响应速度要求高。比如即时通讯，视频通讯，这种情况使用UDP。反之使用TCP

下面给出常见应用使用的协议和端口号

http:TCP,80;

https:TCP:443;

ftp:TCP:21;

smtp:TCP:25

sql:TCP:1433

dns:TCP:53

3.编程方面的区别：

UDP在创建套接字使用的是SOCK_DGRAM而TCP使用的是SOCK_STREAM，UDP不使用Listen和accept、connect这三个函数，而TCP必须使用，UDP发送和接收消息需要sendto/recvfrom，而TCP可以使用send()和recv()，或者read()和write()，正是因为DUP没有三次握手的这个过程，所以看起来会比TCP编程简单很多。

## 问题3：交换机和路由器的区别

1.工作的层次不同

最初的交换机是工作在链路层的（第二层），而路由器的在网络层。

2.数据转发依据的对象不同

交换机是利用物理地址或者可以说是MAC地址来确定转发的数据的目的地址。而路由器是根据不同的网络号即IP地址来确定数据转发的地址。IP是在软件中实现的，描述的是设备所在的网络，而MAC地址是硬件自带的，由网卡生产商类分配，而且已经固化到了网卡中去，一般来说是不可更改的，而IP地址通常由网络管理员或者系统系统分配。

3.交换机只能分割冲突不能分割广播，因为交换机所连的还是同一个局域网，即同一个广播域，而路由器可以分割广播，因为其可以连接不同的网段，即广播可以穿透路由器不能穿透广播。

## 问题4：TCP的流量控制

所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口实现流量控制，如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。

在这里要强调一点：坚持计时器

目的：主要解决零窗口大小通知可能导致的死锁问题

死锁问题的产生：当接收端的窗口大小为0时，接收端向发送端发送一个零窗口报文段，发送端即停止向对端发送数据。此后，如果接收端缓存区有空间则会重新给发送端发送一个窗口大小，即窗口更新。但接收端发送的这个确认报文段有可能会丢失，而此时接收端不知道已经丢失并认为自己已经发送成功，则一直处于等待数据的状态；而发送端由于没有收到该确认报文段，就会一直等待对方发来新的窗口大小，这样一来，双方都处在等待对方的状态，这样就形成了一种死锁问题。如果没有应对措施，这种局面是不会被打破的。为了解决这种问题，TCP为每一个连接设置了坚持计时器。

工作原理：当发送端TCP收到接收端发来的零窗口通知时，就会启动坚持计时器。当计时器的期限到达时，发送端就会主动发送一个特殊的报文段告诉对方确认已经丢失，必须重新发送。【这个特殊的报文段就称为探测报文段，探测报文段只有1个字节的大小，里边只有一个序号，该序号不需要被确认，甚至在计算其他部分数据的确认时该序号会被忽略。

截止期的设置：设置为重传时间的值。但如果没有收到接收端的响应，则会发送另一个探测报文段，并将计时器的值加倍并复位，直到大于门限值（一般为60秒）。在此之后，发送端会每隔60秒发送一个探测报文段，直到窗口重新打开。（注意TCP的四个计时器）

## 问题5：TCP的拥塞控制

[http://lishuaii.top/2018/04/02/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/](http://lishuaii.top/2018/04/02/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/)
链接中有详解！
